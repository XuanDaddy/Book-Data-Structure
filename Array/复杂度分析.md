# 【五】复杂度分析

### 时间复杂度

时间复杂度简单描述是指算法的运行时间和输入数据之间的关系，常用大O来表示，其中数据量用n表示，描述n趋近于无穷的情况。

常见的几种时间复杂度：

* O(1)
* O(n)：算法时间与数据量n呈线性关系；
* O(lgn)
* O(nlogn)
* O(n^2)

### 动态数组复杂度

| 操作类型       | 方法             | 时间复杂度 | 备注             |
| -------------- | ---------------- | ---------- | ---------------- |
| 添加到末尾     | addLast(e)       | O(1)       | 最坏情况扩容O(n) |
| 添加到第一个   | addFrist(e)      | O(n)       |                  |
| 添加到指定位置 | add(index,e)     | O(n)       |                  |
| 删除末尾       | removeLast(e)    | O(1)       |                  |
| 删除第一个     | removeFirst(e)   | O(n)       |                  |
| 删除指定位置   | remove(index,e)  | O(n)       |                  |
| 修改元素       | set(index, e)    | O(1)       |                  |
| 查询元素       | get(index)       | O(1)       |                  |
| 是否包含元素   | contains(e)      | O(n)       |                  |
| 查询元素位置   | find(e)          | O(n)       |                  |
| 扩容           | resize(capacity) | O(n)       |                  |

综合来看：

* 添加操作：O(n)；
* 删除操作：O(n)；
* 修改操作：已知索引O(1)，未知索引O(n)；
* 查询操作：已知索引O(1)，未知索引O(n)；

### 均摊复杂度

如上表所示，在末尾添加元素，最坏的情况会进行扩容，时间复杂度为变为O(n)，但不是每次添加都会扩容，因为扩容后容量变为2倍。

> 假设capacity = n，n + 1次addLast，触发resize，总共进行2n + 1次基本操作（n次数据转换，n+1次数组赋值）。
>
> 平均，每次addLast操作，进行2次基本操作`(2n + 1)/n`。

这样均摊计算到每次添加操作，addLast的时间复杂度是O(1)，removeLast同理。

### 复杂度震荡

如数组元素刚好是容量的一半，进行了缩容，接着又添加一个元素，又进行扩容，再删除一个元素，如此反复...时间复杂度激增。

解决方案：

当数组元素只有容量的1/4时，才进行缩容，缩容的容量为当前容量的1/2。